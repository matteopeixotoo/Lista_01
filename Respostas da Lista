Nome: Matteo Peixoto
Matricula: 20230094622
Aluno: Rickson Régis de Oliveira Falcão
Matrícula: 2022004480

Questao 1:
◦ p == &i;
A resposta de saída serio o número inteiro 3, visto que a expressão verifica se o valor do ponteiro p está igual ao que está no endereço de i.

◦ *p - *q;
A resposta seria o número inteiro -2. O ponteiro p esta apontando para o endereço que armazena o conteúdo da variável do tipo inteiro i, enquanto q está apontando para o endereço de j (também inteiro).

◦ **&p;
Irá retornar o valor de i, porque o ponteiro p aponta para o endereço de i.

◦ 3 - *p/(*q) + 7;
Aqui o que aconteceu foi que, como definimos o tipo inteiro para as variáveis, a fração 3/5 é igual 0, tornando o resultado da expressão 3-0+7 = 10.

---------------------------

Questao 2:
  1) p = Endereço de i (p): 4094;
  2) p+1 = Endereço de i+1 (p+1): 4094 + 2 (tamanho de int em bytes) = 4096.
  3) *p+2 = O conteúdo do endereço de i somado a 2, ou seja, 5+2 = 7.
  4) **&p = Retorna o valor que está armazenado no endereço apontado pelo endereço de p, no caso 5.
  5) 3**p = *p retorna o conteúdo armazendo em i, logo 3 * *p = 3 * 5 = 15.
  6) **&p+4 = Desreferencia 2x o endereço, retornando o valor de i, logo 5 + 4 = 9.

---------------------------
Questao 3:
(LEGAL) p = &i -> o ponteiro de p pode ser atribuído ao endereço de i. 
(ILEGAL) *q = &j -> &j retorna o endereço de j, que não é do tipo ponteiro, portanto é irregular.
(LEGAL) p = &*&i -> *&i desreferencia o endereço de i, voltando apenas o valor, porém ainda sobra o "&" do início, fazendo com que o ponteiro p ainda retorne o endereço de i.
(ILEGAL) i = (*&)j -> "(*&)" não tem significado em C. O uso de * seguido de "&" cancelaria o efeito do outro, o que não faz sentido em C quando sozinhos.
(LEGAL) i = *&j -> Com a desreferenciação do endereço j, o valor de j será atribuído a i.
(LEGAL) i = *&*&j -> Com a dupla desreferenciação do endereço j, o valor de j será atribuído a i.
(ILEGAL) q = *p -> atribui o valor apontado por p ao ponteiro q.
(ILEGAL) i = (*p)++ + *q -> ++ só pode ser adicionado para incrementar a uma variável.

---------------------------
Questao 4:
  <resposta da questao 4 após compilar>
  20 -> Em /* (a) */, foi atribuído a variável "valor" (defina para o tipo inteiro) o número inteiro 10, p1 aponta para o endereço dessa variável e na próxima linha, o número inteiro 20 é atribuído a *p1, alterando o que está armazenado na variável "valor".
  29.0 -> Em /* (b) */, foi atribuído a variável "temp" (defina para o tipo ponto flutuante) o número 26.5, p2 aponta para o endereço dessa variável e na próxima linha, o número 29.0 é atribuído a *p2, alterando o que está armazenado na variável "temp" e imprimindo um valor em ponto flutuante com uma casa decimal.
  P -> Em /* (c) */, "nome" ponteiro para a primeira posição da string "Ponteiros", p3 recebe o endereço da primeira posição da string, imprimindo P.
  e -> Em /* (d) */, "nome" ponteiro para a primeira posição da string "Ponteiros", p3 recebe o endereço da quinta posição da string, imprimindo e.
  P -> Em /* (e) */, "nome" ponteiro para a primeira posição da string "Ponteiros", p3 recebe o endereço da primeira posição da string, imprimindo P.
  e -> Em /* (f) */, p3 + 4 move o ponteiro p3 quatro posições adiante na memória, o que significa que agora p3 aponta para o quinto caractere da string, imprimindo e.
  t -> Em /* (g) */, o ponteiro p3 que apontava para a quinta posição foi decrementado em uma posição, retornando o valor t.
  31 -> Em /* (h) */, p4 é declarado como um ponteiro para int, p4 = vetor atribui o endereço do primeiro elemento do array vetor ao ponteiro p4, apontando para vetor[0].
  45 -> Em /* (i) */, p5 é declarado como um ponteiro para int, p5 = p4 + 1: move o ponteiro p5 para uma posição depois de p4, apontando para vetor[1].
  27 -> Em /* (j) */, p4 = p5 + 1: move o ponteiro p4 para uma posição depois de p5, atribuindo o valor armazenado no endereço e apontando para vetor[2].
  31 -> Em /* (l) */, p4 = p4 - 2: retorna o ponteiro p4 a posição da alternativa /* (h) */, apontando para vetor[0].
  45 -> Em /* (m) */, p5 = &vetor[2] - 1: atribui ao ponteiro p5 o valor armazenado no endereço vetor[1], sendo esse 45.
  27 -> Em /* (n) */, p5++ incrementa um endereço a mais para o ponteiro p5, que antes estava no endereço do vetor[1], agora passa para o endereço do vetor [2], fazendo com que a saída tenha o valor de 27.

---------------------------
Questao 5:
A função for promove a iteração de i = 0 até i = 4. Para cada iteração:

printf("i = %d",i): Irá imprimir o valor do contador i.
printf(" vet[%d] = %.1f",i, vet[i]): Irá imprimir o valor do elemento vet[i].
printf(" *(f + %d) = %.1f",i, *(f+i)): Irá imprimir o valor do elemento acessado através do ponteiro f.
printf(" &vet[%d] = %X",i, &vet[i]): Irá imprimir o endereço de memória do elemento vet[i].
printf(" (f + %d) = %X",i, f+i): Irá imprimir o endereço de memória do elemento acessado através do ponteiro f.
printf("\n"): Irá imprimir uma nova linha para separar as entradas da tabela.

---------------------------

Questao 6:
*(pulo + 2): A expressão refere-se ao valor do terceiro elemento do vetor. Adiciona 2 ao endereço base de pulo e sua saída será o velor contido nesse endereço (o terceiro). A expressão pulo + 2 não retorna o valor, e sim o endereço do terceiro elemento.
---------------------------

Questao 7:
- p = mat + 1; é valida pois atribui a p o endereço do segundo elemento do array (mat + 1 calcula o endereço do próximo elemento do array).
- p = mat; também é válida pois atribui a p o endereço do primeiro elemento do array mat.
- (?) p = mat; também é válida pois atribui a p o endereço do primeiro elemento do array mat.
- x = (*mat); atribui a x o valor do primeiro elemento do array mat, portanto, também é válida.
---------------------------

Questao 8:
  1º programa: 
int vet[] = {4, 9, 13} declara um array de tipo inteiro e introduz seus elementos;
int i irá declarar a variável i que será usada como contador no loop for.
for vai iterar os elementos do array utilizando a variável i. quando i = 0 retornará o primeiro elemento (4), quando i = 1 retornará o segundo elemento (9) e quando i = 2 retornará o terceiro elemento (13).
Sendo assim, a saída imprime os elementos do array vet separados por espaços (printf("%d ", *(vet+i));).

Saída: 4 9 13 
  2º programa: 
Se assemelha ao 1º programa, porém printf("%X ", vet + i) imprimirá o endereço de memória do elemento atual do array vet, usando o formato hexadecimal e seguido de um espaço.

Saída: [endereços de memória do primeiro elemento] [endereços de memória do segundo elemento] [endereços de memória do terceiro elemento]

---------------------------

Questao 9:
A saída retornará erros, que serão:
  - Definição do vetor nome[] do tipo char dentro do struct teste, sendo que ao tentar acessá-lo, foi usado s->name em vez de s->nome.
  - A variável x e o vetor nome estão sendo declarados na definição do struct.
  - Não alocação de memoria para o ponteiro s inicialmente, o que poderia ser feito declarando uma variável da estrutura teste e atribuindo seu endereço ao ponteiro s.
---------------------------

Questao 10:
A saída retornará erros, que serão:
  - A função main deveria retornar um tipo int, não void.
  - O valor de x não pode ser modificado pois foi declarado como constante.
------------------------------------------------------

Questao 11:
 - Se x for declarado como char, cada elemento ocupará 1 byte na memória.
    x+1 = 4092 + 1 = 4093
    x+2 = 4092 + 2 = 4094
    x+3 = 4092 + 3 = 4095

 - Se x for declarado como int, cada elemento ocupará 2 bytes na memória.
    x+1 = 4092 + 2 = 4094
    x+2 = 4092 + 4 = 4096
    x+3 = 4092 + 6 = 4098

 - Se x for declarado como float, cada elemento ocupará 4 bytes na memória.
    x+1 = 4092 + 4 = 4096
    x+2 = 4092 + 8 = 4100
    x+3 = 4092 + 12 = 4104

 - Se x for declarado como double, cada elemento ocupará 8 bytes na memória
    x+1 = 4092 + 8 = 4100
    x+2 = 4092 + 16 = 4108
    x+3 = 4092 + 24 = 4116

O código feito ficou assim (supondo que int ocupe 2 bytes, utilizei o short para simular):

#include <stdio.h>

int main(void){

  printf("Tamanho do char: %lu\n", sizeof(char));
  printf("Tamanho do int: %lu\n", sizeof(short));
  printf("Tamanho do float: %lu\n", sizeof(float));
  printf("Tamanho do double: %lu\n", sizeof(double));
  
  char a, *x1;
  x1 = &a;
  printf("\nEndereço do char     = %p\n", x1);
  x1 = x1 + 1;
  printf("Endereço do char + 1 = %p\n", x1);
  x1 = x1 + 1;
  printf("Endereço do char + 2 = %p\n", x1);
  x1 = x1 + 1;
  printf("Endereço do char + 3 = %p\n", x1);

  short b, *x2;
  x2 = &b;
  printf("\nEndereço do int     = %p\n", x2);
  x2 = x2 + 1;
  printf("Endereço do int + 1 = %p\n", x2);
  x2 = x2 + 1;
  printf("Endereço do int + 2 = %p\n", x2);
  x2 = x2 + 1;
  printf("Endereço do int + 3 = %p\n", x2);
  
  float c, *x3;
  x3 = &c;
  printf("\nEndereço do float     = %p\n", x3);
  x3 = x3 + 1;
  printf("Endereço do float + 1 = %p\n", x3);
  x3 = x3 + 1;
  printf("Endereço do float + 2 = %p\n", x3);
  x3 = x3 + 1;
  printf("Endereço do float + 3 = %p\n", x3);

  double d, *x4;
  x4 = &d;
  printf("\nEndereço do double     = %p\n", x4);
  x4 = x4 + 1;
  printf("Endereço do double + 1 = %p\n", x4);
  x4 = x4 + 1;
  printf("Endereço do double + 2 = %p\n", x4);
  x4 = x4 + 1;
  printf("Endereço do double + 3 = %p\n", x4);

}

O resultado de saída encontrado foi:

Tamanho do char: 1
Tamanho do int: 2
Tamanho do float: 4
Tamanho do double: 8

Endereço do char     = 0x7ffe0c6399bf
Endereço do char + 1 = 0x7ffe0c6399c0
Endereço do char + 2 = 0x7ffe0c6399c1
Endereço do char + 3 = 0x7ffe0c6399c2

Endereço do int     = 0x7ffe0c6399bc
Endereço do int + 1 = 0x7ffe0c6399be
Endereço do int + 2 = 0x7ffe0c6399c0
Endereço do int + 3 = 0x7ffe0c6399c2

Endereço do float     = 0x7ffe0c6399b8
Endereço do float + 1 = 0x7ffe0c6399bc
Endereço do float + 2 = 0x7ffe0c6399c0
Endereço do float + 3 = 0x7ffe0c6399c4

Endereço do double     = 0x7ffe0c6399b0
Endereço do double + 1 = 0x7ffe0c6399b8
Endereço do double + 2 = 0x7ffe0c6399c0
Endereço do double + 3 = 0x7ffe0c6399c8

Observamos então que há um salto de 1 em 1 no endereço de char, de 2 em 2 no endereço de int (supondo que int ocupa 2 bytes), de 4 em 4 no endereço de float e de 8 em 8 para o endereço de double.

---------------------------
Questao 12:
 - aloha[2] = value;: Válido. Atribui o valor da variável "value" ao terceiro elemento do vetor "aloha".
 - scanf("%f", &aloha);: Inválido. A função scanf espera um ponteiro como argumento para armazenar o valor lido, mas aloha é um vetor e não pode ser usado como um ponteiro.
 - aloha = "value";: Inválido. Dessa forma, "value" será uma string e não poderá ser colocado em um vetor de float.
 - printf("%f", aloha);: Inválido. Como dito na questão passada, aloha é um vetor de floats, para isso funcionar, teriamos que especificar um dado em específico.
 - coisas[4][4] = aloha[3];: Válido. Estaríamos atribuindo o conteúdo armazenado na quarta linha do vetor aloha na quinta linha e quinta coluna do vetor coisas (de duas dimensões).
 - coisas[5] = aloha;: Inválido. Mais uma vez, aloha é um vetor de floats e não poderia ser armazenado na sexta linha de um vetor bidimensional (como podemos perceber, as linhas do vetor coisas tem 5 dados).
 - pf = value;: Inválido. Como pf é um ponteiro para float e value é só um float. Para funcionar, a função seria "pf = &value", levando o endereço de value ao ponteiro pf, assim atribuindo o valor.
 - pf = aloha;: Válido. Como pf é um ponteiro para float e aloha é um vetor de floats, o comando funciona e pf aponta para aloha[0].
 
---------------------------
Questao 13:
  Memory leak (ou vazamento de memória) é um problema que se inicia através do gerenciamento incorreto da alocação dinâmica e ocorre quando algum programa não libera para o sistema operacional memória que não é mais utilizada. É comum em C, pois a linguagem não oferece nenhum recurso para gerencia de memória automática.

Primeiro código encontrado:

#include <stdio.h>
#include <stdlib.h>

int main() {
    int *x = malloc(10 * sizeof(int));
    printf("Vetor x:\n");
    for (int i = 0; i < 10; ++i) {
        x[i] = i * 10;
        printf("%d ", x[i]);
    }
    return 0;
}

  - Nesse simples código, a memória alocada não é liberada.

Segundo código encontrado:

#include <stdio.h>
#include <stdlib.h>

int main() {
    int *x = malloc(sizeof(int));
    int *y = malloc(sizeof(int));
    int *z = malloc(sizeof(int));

    printf("Ponteiros alocados dinamicamente:\n");
    *x = 10;
    *y = 20;
    *z = 30;
    printf("x: %d\n", *x);
    printf("y: %d\n", *y);
    printf("z: %d\n", *z);

    free(x);
    free(z);
    return 0;
}

  - No segundo, apenas duas alocações são liberadas.

Terceiro código encontrado:

#include <stdio.h>
#include <stdlib.h>

void simulateMemoryLeakInLoop() {
    while (1) {
        int *x = malloc(sizeof(int)); // alocação de memória dinâmica
        if (x == NULL) {
            printf("Houve uma falha na alocação de memória!\n");
            return;
        }

        *x = 42; // Atribuir um valor ao ponteiro (simulação)
    }
}

  - A memória alocada dinamicamente para o ponteiro x não é liberada dentro do loop, resultando em vazamento de memória contínuo.

int main() {
    simulateMemoryLeakInLoop(); 
    return 0;
}

---------------------------
Questao 14:
  <resposta da questao 2>
---------------------------
Questao 15:
  <resposta da questao 2>
---------------------------
Questao 16:
  <resposta da questao 2>
---------------------------
Questao 17:
  <resposta da questao 2>
---------------------------
Questao 18:
  <resposta da questao 2>
---------------------------
Questao 19:
  <resposta da questao 2>
---------------------------
Questao 20:
  <resposta da questao 2>
---------------------------
Questao 21:
  <resposta da questao 2>
---------------------------
Questao 22:
  <resposta da questao 2>
---------------------------
Questao 23:
  <resposta da questao 2>
---------------------------
Questao 24:
  <resposta da questao 2>
---------------------------
Questao 25:
  <resposta da questao 2>
---------------------------
